/*******************************************************************************
*         McStas instrument definition URL=http://www.mcstas.org
*
* Instrument: MAPS with Guide upgrade
*
* %Identification
* Written by: R. A. Ewings, R. I. Bewley
* Date: 23rd Jan 2020.
* Origin: <a href="http://www.isis.stfc.ac.uk">ISIS (UK)</a>
*
* Instrument short description:
* The Multi-Angle Position Sensitive (MAPS) spectrometer was the first neutron
* time-of-flight spectrometer to have a large array of position sensitive detectors
* optimised for the study of magnetic excitations in single crystals.
* Operating since 2000 it was upgraded with a guide system in 2017.
*
* This instrument definition includes the upgraded guide design as of March 9th 2015.
*
* %Example:
*
* %Parameters
* INPUT PARAMETERS:
* ei       : incident energy            [meV]
* freq     : chopper frequency          [Hz]
* chopper  : chopper package            ['a', 's', 'g']
*
* Only a narrow energy range around the specified ei will be generated by the
* moderator in this instrument file.
*
* Note that MAPS currently only run with the "A" or "S" choppers. A new Gd chopper
* is in design and the parameters for it are included here.
*
* %L
* <a href="http://www.isis.stfc.ac.uk/instruments/maps">http://www.isis.stfc.ac.uk/instruments/maps</a>
* %End
*******************************************************************************/

DEFINE INSTRUMENT MAPS(Ei=20, freq=600.0, string chopper="S")
DECLARE
%{
/* chopper variables to compute according to "type" input */
double c_h1,c_h2, roc, chan_w,phase_time,slit_curv,num_slits,width,length,lam;
int nslits;
double E_min, E_max;
double pack_radius, burst;
%}

INITIALIZE
%{
switch(chopper[0]) {
  case 'a':
  case 'A':
    slit_curv=1./1.3;
    num_slits=64;
    length=0.098;
    width=0.001087;
    fprintf(stderr,"A chopper selected\n");
    break;
  case 's':
  case 'S':
    slit_curv=1./1.3;
    num_slits=24;
    length=0.098;
    width=0.002899;
    fprintf(stderr,"MAPS Sloppy selected selected\n");
    break;
  case 'g':
  case 'G':
    slit_curv=0;
    num_slits=107;      // == 2*radius/total_width; radius=55mm -> == 110/(0.02+0.65)
    length=0.022;       // Package length in m
    width=0.65/1000.;   // Slit width in m (of Al)
    fprintf(stderr,"Gadolinium selected selected\n");
    break;
  default:
    fprintf(stderr,"Chopper Type not recognised\n");
    exit(1);
}
/* hardwired for FC position 10.1m from moderator */
phase_time = 10.1 / (SE2V * sqrt(Ei)) + 10e-6;
lam = sqrt(81.81/Ei);
pack_radius = 0.055;
burst = width / (pack_radius * freq / 6.283185);
E_min = 10.1 / (phase_time + burst) / SE2V; E_min *= E_min;
E_max = 10.1 / (phase_time - burst) / SE2V; E_max *= E_max;
%}

TRACE

COMPONENT Origin = Arm()
  AT (0,0,0) ABSOLUTE

/* Merlin style moderator - not sure about relative origin, but anyway */
COMPONENT moderator = ViewModISIS(
    Face = "TS1_S01_Maps.mcstas", E0 = E_min, E1 = E_max,
    dist = 1.7, focus_xw = 0.094, focus_yh = 0.094, modPosition=0, xw=0.12, yh=0.12)
 AT (0,0,0) RELATIVE Origin ROTATED (0, 0, -32) ABSOLUTE
  EXTEND
  %{
      // JSON encoded string for parameters needed by HORACE.
      char eniius_data[] =
          "{'function_pulse_shape': \
                {'type':'NXnote', 'value': { \
                    'data': '\
def mcstas_time_profile(Face, Ei):<nl>\
<tb>with open(Face, <qt>r<qt>) as f:<nl>\
<tb><tb>dat = f.read().replace(<qt>(<qt>,<qt><qt>).replace(<qt>)<qt>,<qt><qt>).split(<qt><bs>n<qt>)<nl>\
<tb>id0, en, intens = (dat.index(<qt> time <qt>), [], [])<nl>\
<tb>n = dat.index(<qt> time <qt>, id0 + 1) - id0 - 6<nl>\
<tb># time data originally in ns, energy in MeV<nl>\
<tb>t = np.loadtxt(dat[(id0+1):(id0+n)], usecols=(0)) / 100<nl>\
<tb>dt = np.diff(t)<nl>\
<tb>while True:<nl>\
<tb><tb>e0 = np.loadtxt(dat[id0-2].split()[2:5:2]) * 1.e9<nl>\
<tb><tb>i0 = np.loadtxt(dat[(id0+1):(id0+n)], usecols=(1))<nl>\
<tb><tb>en.append(np.mean(e0))<nl>\
<tb><tb>intens.append((i0[:-1] / dt) / (e0[1] - e0[0]))<nl>\
<tb><tb>try:<nl>\
<tb><tb><tb>id0 = dat.index(<qt> time <qt>, id0 + 1)<nl>\
<tb><tb>except ValueError:<nl>\
<tb><tb><tb>break<nl>\
<tb>en, intens, tlog = (np.log(en), np.array(intens), np.log(t))<nl>\
<tb>kp = np.where(t < 2000)[0]<nl>\
<tb>ie = np.where(en < np.log(Ei))[0][-1]<nl>\
<tb>frac = (np.log(Ei) - en[ie]) / (en[ie+1] - en[ie])<nl>\
<tb>return intens[ie,kp] + frac * (intens[ie+1,kp] - intens[ie,kp])<nl>',\
                    'globals': 'np:numpy, open:open, ValueError:ValueError',\
                    'type': 'text/x-python', \
                    'description': 'Python script to compute moderator time profile from Ei'} \
                }}";
  %}

COMPONENT aperture = Slit(
    xmin = -0.047, xmax = 0.047, ymin = -0.047, ymax = 0.047)
  AT (0, 0, 1.7) RELATIVE Origin
  EXTEND
  %{
      // JSON encoded string for parameters needed by HORACE.
      char eniius_data[] =
          "{'parameter_function': \
                {'type':'NXnote', 'value': { \
                    'data': '\
def scale_x_gap(Ei):<nl>\
<tb>l = np.sqrt(81.804201263673718 / np.array(ei))<nl>\
<tb>if l > 4.5:<nl>\
<tb><tb>gain = 11.9644283524285 + 3.3130483907728 * (l - 4.5)<nl>\
<tb>else:<nl>\
<tb><tb>gain = 1 + np.exp(-2.31186757913804 / l) * (23.2965476737752 + \
                - 15.1289612048092 * l + 6.11185114079924 * l * l \
                - 0.863318992430536 * l * l + 0.0439354263500835 * l * l * l)<nl>\
<tb>return gain<nl>\
def scale_y_gap(Ei):<nl>\
<tb>return scale_x_gap(Ei)<nl>', \
                    'globals': 'np:numpy',\
                    'type': 'text/x-python', \
                    'description': 'Python script to compute aperture parameter from Ei'} \
                }}";
  %}

COMPONENT guide1_shutter = Guide_channeled(
    w1 = 0.094, h1 = 0.094, w2 = 0.08515, h2 = 0.08515, l = 1.9373, alphax = 4.38, alphay = 4.38 ,
 W=3e-3, mx = 3, my = 3)
  AT (0, 0, 1.7546) RELATIVE Origin

COMPONENT guide2_converging = Guide_channeled(
    w1 = 0.0847, h1 = 0.0847, w2 = 0.0650, h2 = 0.0650, l = 4.300, alphax = 4.38, alphay = 4.38 ,
 W=3e-3, mx = 3, my = 3)
  AT (0, 0, 3.791) RELATIVE Origin

COMPONENT guide3_betweenchoppers = Guide_channeled(
    w1 = 0.06090, h1 = 0.06090, w2 = 0.05703, h2 = 0.05703, l = 0.847, alphax = 4.38, alphay = 4.38 ,
 W=3e-3, mx = 3, my = 3)
  AT (0, 0, 9.00) RELATIVE Origin

COMPONENT fermi = FermiChopper(delay=phase_time, radius=pack_radius, nu=-freq,
  yheight=0.07, w=width, nslit=num_slits, R0=0.0,
  Qc=0.02176, alpha=2.33, m=0, length=length, eff=0.95, curvature=slit_curv, zero_time=0)
  AT (0,0,10.1) RELATIVE Origin

COMPONENT guide4_final = Guide_channeled(
    w1 = 0.05432, h1 = 0.05432, w2 = 0.04883, h2 = 0.04883, l = 1.203, alphax = 4.38, alphay = 4.38 ,
 W=3e-3, mx = 3, my = 3)
  AT (0, 0, 10.439) RELATIVE Origin

/* Pre-sample slit - now is 48x48mm, which is smaller than before */
COMPONENT sampleslit1 = Slit(
    xmin = -0.024, xmax = 0.024, ymin = -0.024, ymax = 0.024)
  AT (0, 0, 11.7) RELATIVE Origin

COMPONENT sample_position = Arm()
  AT (0, 0, 12.0) RELATIVE Origin

COMPONENT sample = Incoherent(
  radius = 0.04, yheight = 0.04, thickness = 0.005)
  AT (0, 0, 0) RELATIVE sample_position

// MAPS has a weird shaped detector array, model it as two parts
COMPONENT det_lowang = Monitor_nD(
    options = "banana, auto t bins=200, theta limits[-19.8 19.8] bins=200",
    filename = "Detector.dat",  radius=6.0,  yheight = 4.0)
  AT (0, 0, 0) RELATIVE sample_position

COMPONENT det_strip = Monitor_nD(
    options = "banana, auto t bins=200, theta limits[21.1 59.7] bins=200",
    filename = "Detector.dat",  radius=6.0,  yheight = 1.0)
  AT (0, 0, 0) RELATIVE sample_position

END
